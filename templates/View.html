


<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>3D GeoJSON Viewer</title>
  <script src="https://cesium.com/downloads/cesiumjs/releases/1.114/Build/Cesium/Cesium.js"></script>
  <link href="https://cesium.com/downloads/cesiumjs/releases/1.114/Build/Cesium/Widgets/widgets.css" rel="stylesheet" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.8.0/proj4.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/jstree/3.3.12/themes/default/style.min.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jstree/3.3.12/jstree.min.js"></script>
  <style>
    html, body { margin: 0; padding: 0; height: 100%; overflow: hidden; font-family: "Segoe UI", sans-serif; }
    #mainContainer { display: flex; height: 100%; width: 100%; }
    #cesiumContainer { flex-grow: 1; background: white; }
    #sidebar {
      width: 340px;
      color: #1e1e1e;
      background: #f0f0f0;
      overflow-y: auto;
      border-left: 2px solid #333;
      padding: 10px;
      box-sizing: border-box;
    }
    #sidebar h4 {
      margin: 10px 0;
      font-size: 18px;
      border-bottom: 1px solid #444;
      padding-bottom: 5px;
    }
    .jstree-anchor { color: #1e1e1e !important; }
    #sidebar::-webkit-scrollbar { width: 6px; }
    #sidebar::-webkit-scrollbar-thumb { background-color: #444; }
    #sidebar::-webkit-scrollbar-thumb:hover { background: #888; }
  </style>
</head>
<body>
<div id="mainContainer">
  <div id="cesiumContainer"></div>
  <div id="sidebar">
    <h4>GeoJSON Structure</h4>
    <div id="jstree-panel"></div>
  </div>
</div>
<script>
  const inputGeojson = {{ geojson_data | safe }};
  const viewer = new Cesium.Viewer("cesiumContainer", {
    animation: false,
    timeline: false,
    baseLayerPicker: false,
    skyBox: false,
    skyAtmosphere: false,
    geocoder: false,
    homeButton: false,
    sceneModePicker: false,
    navigationHelpButton: false,
    infoBox: true,
    selectionIndicator: true,
    fullscreenButton: false,
    sceneMode: Cesium.SceneMode.SCENE3D
  });
  viewer.scene.backgroundColor = Cesium.Color.WHITE;
  proj4.defs("EPSG:32638", "+proj=utm +zone=38 +datum=WGS84 +units=m +no_defs");

  const subtypeEntityMap = {}; // subtype â†’ [entities]

  function reprojectGeoJSON(geojson) {
    return {
      type: "FeatureCollection",
      features: geojson.features.map(feature => {
        const coords = feature.geometry.coordinates[0].map(pt =>
          proj4("EPSG:32638", "EPSG:4326", pt)
        );
        return {
          type: "Feature",
          geometry: { type: "Polygon", coordinates: [coords] },
          properties: feature.properties
        };
      })
    };
  }

  function buildJsTreeData(features) {
    const treeData = [];
    const idSet = new Set();
    for (const f of features) {
      const p = f.properties;
      const CADCODE = p.CADCODE || "??";
      const REG_N = p.REG_N || "??";
      const FLOOR = String(p.FLOOR || "??");
      const TYPE = p.TYPE || "??";
      const SUB_TYPE = p.SUB_TYPE || "??";

      const ids = [
        `cad:${CADCODE}`,
        `cad:${CADCODE}/reg:${REG_N}`,
        `cad:${CADCODE}/reg:${REG_N}/floor:${FLOOR}`,
        `cad:${CADCODE}/reg:${REG_N}/floor:${FLOOR}/type:${TYPE}`,
        `cad:${CADCODE}/reg:${REG_N}/floor:${FLOOR}/type:${TYPE}/subtype:${SUB_TYPE}`
      ];

      const texts = [CADCODE, REG_N, `Floor ${FLOOR}`, TYPE, SUB_TYPE];

      for (let i = 0; i < ids.length; i++) {
        const id = ids[i];
        const parent = i === 0 ? "#" : ids[i - 1];
        if (!idSet.has(id)) {
          idSet.add(id);
          treeData.push({ id, parent, text: texts[i], state: { opened: true } });
        }
      }
    }
    return treeData;
  }

  function initializeJsTree(treeData) {
    $('#jstree-panel').jstree('destroy');
    $('#jstree-panel').jstree({
      'core': { 'data': treeData, 'themes': { 'stripes': true } },
      'plugins': ["checkbox"]
    });

    $('#jstree-panel').on('changed.jstree', function (e, data) {
      const visibleSubtypes = new Set();
      data.selected.forEach(id => {
        if (id.includes("subtype:")) {
          const subtype = id.split("subtype:")[1];
          visibleSubtypes.add(subtype);
        }
      });
      for (const subtype in subtypeEntityMap) {
        const visible = visibleSubtypes.has(subtype);
        subtypeEntityMap[subtype].forEach(ent => ent.show = visible);
      }
    });
  }

 function processGeoJSON(data) {
  const reprojected = reprojectGeoJSON(data);
  Cesium.GeoJsonDataSource.load(reprojected, { clampToGround: false }).then(dataSource => {
    viewer.dataSources.add(dataSource);
    viewer.zoomTo(dataSource);

  let baseHeight = 0;
let stairCountsPerFloor = {};
const entities = dataSource.entities.values;

// Step 1: Get baseHeight from kedeli
for (let entity of entities) {
  if (!entity.polygon) continue;

  const sub = entity.properties?.SUB_TYPE?.getValue(Cesium.JulianDate.now())?.toLowerCase() || "";
   if (!subtypeEntityMap[sub]) {
        subtypeEntityMap[sub] = [];
      }
      subtypeEntityMap[sub].push(entity);

  const height = parseFloat(entity.properties?.HEIGHT?.getValue(Cesium.JulianDate.now()) || 0);

  

  if (sub.includes("ked")) {
    baseHeight = height;
  }
}

// Step 2: Count staircases per floor
for (let entity of entities) {
  if (!entity.polygon) continue;

  const sub = entity.properties?.SUB_TYPE?.getValue(Cesium.JulianDate.now())?.toLowerCase() || "";
  const floor = entity.properties?.FLOOR?.getValue(Cesium.JulianDate.now()) || 0;

  if (sub.includes("kib")) {
    if (!stairCountsPerFloor[floor]) {
      stairCountsPerFloor[floor] = 0;
    }
    stairCountsPerFloor[floor]++;
  }
}

// Step 3: Apply drawing logic
for (let entity of entities) {
  if (!entity.polygon) continue;

  const sub = entity.properties?.SUB_TYPE?.getValue(Cesium.JulianDate.now())?.toLowerCase() || "";
  const height = parseFloat(entity.properties?.HEIGHT?.getValue(Cesium.JulianDate.now()) || 0);
  const floor = entity.properties?.FLOOR?.getValue(Cesium.JulianDate.now()) || 0;
  const hierarchy = entity.polygon.hierarchy.getValue(Cesium.JulianDate.now());
  const base = baseHeight * (floor - 1);

  if (sub.includes("ked") || sub.includes("kol")) {
    entity.polygon.height = base;
    entity.polygon.extrudedHeight = base + height;
    entity.polygon.material = Cesium.Color.GRAY.withAlpha(0.8);
    entity.polygon.outline = true;
    entity.polygon.outlineColor = Cesium.Color.YELLOW;

  } else if (sub.includes("kar")) {
    entity.polygon.height = base;
    entity.polygon.extrudedHeight = base + height;
    entity.polygon.material = Cesium.Color.BROWN.withAlpha(0.8);

    viewer.entities.add({
      polygon: {
        hierarchy: hierarchy,
        height: entity.polygon.extrudedHeight,
        extrudedHeight: entity.polygon.height + baseHeight,
        material: Cesium.Color.GRAY.withAlpha(0.8),
        outline: true,
        outlineColor: Cesium.Color.YELLOW
      }
    });

  } else if (sub.includes("fan")) {
    const middleStart = base + ((baseHeight - height) / 2) + 0.3;
    const middleEnd = middleStart + height;

    entity.polygon.height = middleStart;
    entity.polygon.extrudedHeight = middleEnd;
    entity.polygon.material = Cesium.Color.AQUA.withAlpha(0.8);

    viewer.entities.add({
      polygon: {
        hierarchy: hierarchy,
        height: middleEnd,
        extrudedHeight: middleStart + ((baseHeight - height) / 2) - 0.3 + height,
        material: Cesium.Color.GRAY.withAlpha(0.8),
        outline: true,
        outlineColor: Cesium.Color.YELLOW
      }
    });

    viewer.entities.add({
      polygon: {
        hierarchy: hierarchy,
        height: base,
        extrudedHeight: middleStart,
        material: Cesium.Color.GRAY.withAlpha(0.8),
        outline: true,
        outlineColor: Cesium.Color.YELLOW
      }
    });

  } else if (sub.includes("iat") || sub.includes("aiv")) {
    console.log("SubType:", sub, "Base Height:", baseHeight, "Object Height:", height);
    entity.polygon.height = base;
    entity.polygon.extrudedHeight = base + 0.1;
    entity.polygon.material = Cesium.Color.BLACK.withAlpha(0.5);

  } else if (sub.includes("kib")) {
    const stairCount = stairCountsPerFloor[floor] || 0;
    entity.polygon.height = base;
    entity.polygon.extrudedHeight = base + 0.3;
    entity.polygon.material = Cesium.Color.BLUE.withAlpha(0.8);

    viewer.entities.remove(entity); // Remove original

  } else if (sub.includes("lif")) {
    entity.polygon.height = base;
    entity.polygon.extrudedHeight = base + baseHeight;
    entity.polygon.material = Cesium.Color.PINK.withAlpha(0.8);

  } else {
    entity.polygon.height = base;
    entity.polygon.extrudedHeight = base + height;
    entity.polygon.material = Cesium.Color.BLACK.withAlpha(0.8);
  }
}


    const treeData = buildJsTreeData(reprojected.features);
    initializeJsTree(treeData);
  });
}


  processGeoJSON(inputGeojson);
</script>
</body>
</html>