<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>3D GeoJSON Viewer</title>
  <script src="https://cesium.com/downloads/cesiumjs/releases/1.114/Build/Cesium/Cesium.js"></script>
  <link href="https://cesium.com/downloads/cesiumjs/releases/1.114/Build/Cesium/Widgets/widgets.css" rel="stylesheet" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.8.0/proj4.js"></script>
  <style>
    html, body, #cesiumContainer {
      width: 100%;
      height: 100%;
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: white;
    }
    canvas {
      background: white !important;
    }
  </style>
</head>
<body>
  <div id="cesiumContainer"></div>
  <script>
    const inputGeojson = {{ geojson_data | safe }};

    const viewer = new Cesium.Viewer("cesiumContainer", {
      animation: false,
      timeline: false,
      baseLayerPicker: false,
      skyBox: false,
      skyAtmosphere: false,
      geocoder: false,
      homeButton: false,
      sceneModePicker: false,
      navigationHelpButton: false,
      infoBox: true,
      selectionIndicator: true,
      fullscreenButton: false,
      sceneMode: Cesium.SceneMode.SCENE3D
    });

    viewer.scene.backgroundColor = Cesium.Color.WHITE;
    proj4.defs("EPSG:32638", "+proj=utm +zone=38 +datum=WGS84 +units=m +no_defs");

    function reprojectGeoJSON(geojson) {
      return {
        type: "FeatureCollection",
        features: geojson.features.map(feature => {
          const coords = feature.geometry.coordinates[0].map(pt =>
            proj4("EPSG:32638", "EPSG:4326", pt)
          );
          return {
            type: "Feature",
            geometry: { type: "Polygon", coordinates: [coords] },
            properties: feature.properties
          };
        })
      };
    }

    function processGeoJSON(data) {
      const reprojected = reprojectGeoJSON(data);
      Cesium.GeoJsonDataSource.load(reprojected, { clampToGround: false }).then(dataSource => {
        viewer.dataSources.add(dataSource);
        viewer.zoomTo(dataSource);
        const entities = dataSource.entities.values;

        let baseHeight = 0;
        let stairCountsPerFloor = {};

        for (let entity of entities) {
          if (!entity.polygon) continue;
          const SubTypes = entity.properties?.SUB_TYPE?.getValue(Cesium.JulianDate.now());
          const ObjectHeights = parseFloat(entity.properties?.HEIGHT?.getValue(Cesium.JulianDate.now()) || 0);
          if ((SubTypes || "").toLowerCase() === "kedeli") baseHeight = ObjectHeights;
        }

        for (let entity of entities) {
          if (!entity.polygon) continue;
          const SubTypes = entity.properties?.SUB_TYPE?.getValue(Cesium.JulianDate.now()) || "";
          const floor = entity.properties?.FLOOR?.getValue(Cesium.JulianDate.now()) || 0;
          if (SubTypes.toLowerCase() === "kibis ujredi") {
            stairCountsPerFloor[floor] = (stairCountsPerFloor[floor] || 0) + 1;
          }
        }

        for (let entity of entities) {
          if (!entity.polygon) continue;
          const SubTypes = entity.properties?.SUB_TYPE?.getValue(Cesium.JulianDate.now());
          const ObjectHeights = parseFloat(entity.properties?.HEIGHT?.getValue(Cesium.JulianDate.now()) || 0);
          const floor = entity.properties?.FLOOR?.getValue(Cesium.JulianDate.now()) || 0;
          const hierarchy = entity.polygon.hierarchy.getValue(Cesium.JulianDate.now());
          const objectStart = baseHeight * (floor - 1);

          if (SubTypes === "kedeli" || SubTypes === "kolona") {
            entity.polygon.height = objectStart;
            entity.polygon.extrudedHeight = objectStart + ObjectHeights;
            entity.polygon.material = Cesium.Color.GRAY.withAlpha(0.8);
            entity.polygon.outline = true;
            entity.polygon.outlineColor = Cesium.Color.YELLOW;
          } else if (SubTypes === "karebi") {
            entity.polygon.height = objectStart;
            entity.polygon.extrudedHeight = objectStart + ObjectHeights;
            entity.polygon.material = Cesium.Color.BROWN.withAlpha(0.8);
            viewer.entities.add({
              polygon: {
                hierarchy,
                height: entity.polygon.extrudedHeight,
                extrudedHeight: entity.polygon.height + baseHeight,
                material: Cesium.Color.GRAY.withAlpha(0.8),
                outline: true,
                outlineColor: Cesium.Color.YELLOW
              }
            });
          } else if (SubTypes === "fanjara") {
            entity.polygon.height = objectStart + ((baseHeight - ObjectHeights) / 2) + 0.3;
            entity.polygon.extrudedHeight = entity.polygon.height + ObjectHeights;
            entity.polygon.material = Cesium.Color.AQUA.withAlpha(0.8);
          } else if (SubTypes === "iataki" || SubTypes === "aivani") {
            entity.polygon.height = objectStart;
            entity.polygon.extrudedHeight = objectStart + 0.1;
            entity.polygon.material = Cesium.Color.BLACK.withAlpha(0.5);
          } else if (SubTypes === "kibis ujredi") {
            entity.polygon.height = objectStart;
            entity.polygon.extrudedHeight = objectStart + 0.3;
            entity.polygon.material = Cesium.Color.BLUE.withAlpha(0.8);
            viewer.entities.remove(entity);
          } else if (SubTypes === "liftis Saxta") {
            entity.polygon.height = objectStart;
            entity.polygon.extrudedHeight = objectStart + baseHeight;
            entity.polygon.material = Cesium.Color.PINK.withAlpha(0.8);
          } else {
            entity.polygon.height = objectStart;
            entity.polygon.extrudedHeight = objectStart + ObjectHeights;
            entity.polygon.material = Cesium.Color.BLACK.withAlpha(0.8);
          }
        }
      });
    }

    processGeoJSON(inputGeojson);

    // Movement setup â€” same as yours
    let isPointerLocked = false;
    const moveSpeed = 0.15;
    const rotateSpeed = 0.002;
    const canvas = viewer.scene.canvas;
    const keysPressed = { w: false, a: false, s: false, d: false, q: false, e: false };

    document.addEventListener("keydown", e => {
      if (e.code === "Enter" && !isPointerLocked) canvas.requestPointerLock();
      if (isPointerLocked) keysPressed[e.code.slice(3).toLowerCase()] = true;
    });

    document.addEventListener("keyup", e => {
      keysPressed[e.code.slice(3).toLowerCase()] = false;
    });

    document.addEventListener("pointerlockchange", () => {
      isPointerLocked = document.pointerLockElement === canvas;
    });

    document.addEventListener("mousemove", e => {
      if (!isPointerLocked) return;
      const camera = viewer.camera;
      const yaw = e.movementX * rotateSpeed;
      const pitch = -e.movementY * rotateSpeed;
      const newPitch = Cesium.Math.clamp(camera.pitch + pitch, -Cesium.Math.PI_OVER_TWO + 0.1, Cesium.Math.PI_OVER_TWO - 0.1);
      camera.setView({ orientation: { heading: camera.heading + yaw, pitch: newPitch, roll: 0.0 } });
    });

    function update() {
      if (isPointerLocked) {
        const camera = viewer.camera;
        if (keysPressed.w) camera.moveForward(moveSpeed);
        if (keysPressed.s) camera.moveBackward(moveSpeed);
        if (keysPressed.a) camera.moveLeft(moveSpeed);
        if (keysPressed.d) camera.moveRight(moveSpeed);
        const yawRate = Cesium.Math.toRadians(1.5);
        if (keysPressed.q) camera.setView({ orientation: { heading: camera.heading - yawRate, pitch: camera.pitch, roll: 0.0 } });
        if (keysPressed.e) camera.setView({ orientation: { heading: camera.heading + yawRate, pitch: camera.pitch, roll: 0.0 } });
      }
      requestAnimationFrame(update);
    }

    update();
  </script>
</body>
</html>
